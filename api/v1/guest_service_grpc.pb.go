// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.12.4
// source: v1/guest_service.proto

package guestProto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Guest_CreateGuest_FullMethodName                   = "/guest_proto.guest/CreateGuest"
	Guest_GetAllGuests_FullMethodName                  = "/guest_proto.guest/GetAllGuests"
	Guest_GetGuestByID_FullMethodName                  = "/guest_proto.guest/GetGuestByID"
	Guest_UpdateGuest_FullMethodName                   = "/guest_proto.guest/UpdateGuest"
	Guest_AddGuestNote_FullMethodName                  = "/guest_proto.guest/AddGuestNote"
	Guest_GetAllGuestFeedback_FullMethodName           = "/guest_proto.guest/GetAllGuestFeedback"
	Guest_GetGuestUpcomingReservations_FullMethodName  = "/guest_proto.guest/GetGuestUpcomingReservations"
	Guest_GetAllGuestReservations_FullMethodName       = "/guest_proto.guest/GetAllGuestReservations"
	Guest_GetGuestStatistics_FullMethodName            = "/guest_proto.guest/GetGuestStatistics"
	Guest_GetGuestSpending_FullMethodName              = "/guest_proto.guest/GetGuestSpending"
	Guest_GetGuestReservationStatistics_FullMethodName = "/guest_proto.guest/GetGuestReservationStatistics"
	Guest_UpdateGuestNote_FullMethodName               = "/guest_proto.guest/UpdateGuestNote"
	Guest_DeleteGuestNote_FullMethodName               = "/guest_proto.guest/DeleteGuestNote"
	Guest_ImportGuestsFromExcel_FullMethodName         = "/guest_proto.guest/ImportGuestsFromExcel"
	Guest_AddReservationVisitors_FullMethodName        = "/guest_proto.guest/AddReservationVisitors"
	Guest_DeleteReservationVisitors_FullMethodName     = "/guest_proto.guest/DeleteReservationVisitors"
)

// GuestClient is the client API for Guest service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestClient interface {
	CreateGuest(ctx context.Context, in *CreateGuestRequest, opts ...grpc.CallOption) (*CreateGuestResponse, error)
	GetAllGuests(ctx context.Context, in *GetAllGuestsRequest, opts ...grpc.CallOption) (*GetAllGuestsResponse, error)
	GetGuestByID(ctx context.Context, in *GetGuestByIDRequest, opts ...grpc.CallOption) (*GetGuestByIDResponse, error)
	UpdateGuest(ctx context.Context, in *UpdateGuestRequest, opts ...grpc.CallOption) (*UpdateGuestResponse, error)
	AddGuestNote(ctx context.Context, in *AddGuestNoteRequest, opts ...grpc.CallOption) (*AddGuestNoteResponse, error)
	GetAllGuestFeedback(ctx context.Context, in *GetAllGuestFeedbackRequest, opts ...grpc.CallOption) (*GetAllGuestFeedbackResponse, error)
	GetGuestUpcomingReservations(ctx context.Context, in *GetGuestUpcomingReservationsRequest, opts ...grpc.CallOption) (*GetGuestUpcomingReservationsResponse, error)
	GetAllGuestReservations(ctx context.Context, in *GetAllGuestReservationsRequest, opts ...grpc.CallOption) (*GetAllGuestReservationsResponse, error)
	GetGuestStatistics(ctx context.Context, in *GetGuestStatisticsRequest, opts ...grpc.CallOption) (*GetGuestStatisticsResponse, error)
	GetGuestSpending(ctx context.Context, in *GetGuestSpendingRequest, opts ...grpc.CallOption) (*GetGuestSpendingResponse, error)
	GetGuestReservationStatistics(ctx context.Context, in *GetGuestReservationStatisticsRequest, opts ...grpc.CallOption) (*GetGuestReservationStatisticsResponse, error)
	UpdateGuestNote(ctx context.Context, in *UpdateGuestNoteRequest, opts ...grpc.CallOption) (*UpdateGuestNoteResponse, error)
	DeleteGuestNote(ctx context.Context, in *DeleteGuestNoteRequest, opts ...grpc.CallOption) (*DeleteGuestNoteResponse, error)
	ImportGuestsFromExcel(ctx context.Context, in *ImportGuestsFromExcelRequest, opts ...grpc.CallOption) (*ImportGuestsFromExcelResponse, error)
	AddReservationVisitors(ctx context.Context, in *AddReservationVisitorsRequest, opts ...grpc.CallOption) (*AddReservationVisitorsResponse, error)
	DeleteReservationVisitors(ctx context.Context, in *DeleteReservationVisitorsRequest, opts ...grpc.CallOption) (*DeleteReservationVisitorsResponse, error)
}

type guestClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestClient(cc grpc.ClientConnInterface) GuestClient {
	return &guestClient{cc}
}

func (c *guestClient) CreateGuest(ctx context.Context, in *CreateGuestRequest, opts ...grpc.CallOption) (*CreateGuestResponse, error) {
	out := new(CreateGuestResponse)
	err := c.cc.Invoke(ctx, Guest_CreateGuest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetAllGuests(ctx context.Context, in *GetAllGuestsRequest, opts ...grpc.CallOption) (*GetAllGuestsResponse, error) {
	out := new(GetAllGuestsResponse)
	err := c.cc.Invoke(ctx, Guest_GetAllGuests_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetGuestByID(ctx context.Context, in *GetGuestByIDRequest, opts ...grpc.CallOption) (*GetGuestByIDResponse, error) {
	out := new(GetGuestByIDResponse)
	err := c.cc.Invoke(ctx, Guest_GetGuestByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) UpdateGuest(ctx context.Context, in *UpdateGuestRequest, opts ...grpc.CallOption) (*UpdateGuestResponse, error) {
	out := new(UpdateGuestResponse)
	err := c.cc.Invoke(ctx, Guest_UpdateGuest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) AddGuestNote(ctx context.Context, in *AddGuestNoteRequest, opts ...grpc.CallOption) (*AddGuestNoteResponse, error) {
	out := new(AddGuestNoteResponse)
	err := c.cc.Invoke(ctx, Guest_AddGuestNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetAllGuestFeedback(ctx context.Context, in *GetAllGuestFeedbackRequest, opts ...grpc.CallOption) (*GetAllGuestFeedbackResponse, error) {
	out := new(GetAllGuestFeedbackResponse)
	err := c.cc.Invoke(ctx, Guest_GetAllGuestFeedback_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetGuestUpcomingReservations(ctx context.Context, in *GetGuestUpcomingReservationsRequest, opts ...grpc.CallOption) (*GetGuestUpcomingReservationsResponse, error) {
	out := new(GetGuestUpcomingReservationsResponse)
	err := c.cc.Invoke(ctx, Guest_GetGuestUpcomingReservations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetAllGuestReservations(ctx context.Context, in *GetAllGuestReservationsRequest, opts ...grpc.CallOption) (*GetAllGuestReservationsResponse, error) {
	out := new(GetAllGuestReservationsResponse)
	err := c.cc.Invoke(ctx, Guest_GetAllGuestReservations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetGuestStatistics(ctx context.Context, in *GetGuestStatisticsRequest, opts ...grpc.CallOption) (*GetGuestStatisticsResponse, error) {
	out := new(GetGuestStatisticsResponse)
	err := c.cc.Invoke(ctx, Guest_GetGuestStatistics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetGuestSpending(ctx context.Context, in *GetGuestSpendingRequest, opts ...grpc.CallOption) (*GetGuestSpendingResponse, error) {
	out := new(GetGuestSpendingResponse)
	err := c.cc.Invoke(ctx, Guest_GetGuestSpending_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) GetGuestReservationStatistics(ctx context.Context, in *GetGuestReservationStatisticsRequest, opts ...grpc.CallOption) (*GetGuestReservationStatisticsResponse, error) {
	out := new(GetGuestReservationStatisticsResponse)
	err := c.cc.Invoke(ctx, Guest_GetGuestReservationStatistics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) UpdateGuestNote(ctx context.Context, in *UpdateGuestNoteRequest, opts ...grpc.CallOption) (*UpdateGuestNoteResponse, error) {
	out := new(UpdateGuestNoteResponse)
	err := c.cc.Invoke(ctx, Guest_UpdateGuestNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) DeleteGuestNote(ctx context.Context, in *DeleteGuestNoteRequest, opts ...grpc.CallOption) (*DeleteGuestNoteResponse, error) {
	out := new(DeleteGuestNoteResponse)
	err := c.cc.Invoke(ctx, Guest_DeleteGuestNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) ImportGuestsFromExcel(ctx context.Context, in *ImportGuestsFromExcelRequest, opts ...grpc.CallOption) (*ImportGuestsFromExcelResponse, error) {
	out := new(ImportGuestsFromExcelResponse)
	err := c.cc.Invoke(ctx, Guest_ImportGuestsFromExcel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) AddReservationVisitors(ctx context.Context, in *AddReservationVisitorsRequest, opts ...grpc.CallOption) (*AddReservationVisitorsResponse, error) {
	out := new(AddReservationVisitorsResponse)
	err := c.cc.Invoke(ctx, Guest_AddReservationVisitors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *guestClient) DeleteReservationVisitors(ctx context.Context, in *DeleteReservationVisitorsRequest, opts ...grpc.CallOption) (*DeleteReservationVisitorsResponse, error) {
	out := new(DeleteReservationVisitorsResponse)
	err := c.cc.Invoke(ctx, Guest_DeleteReservationVisitors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestServer is the server API for Guest service.
// All implementations should embed UnimplementedGuestServer
// for forward compatibility
type GuestServer interface {
	CreateGuest(context.Context, *CreateGuestRequest) (*CreateGuestResponse, error)
	GetAllGuests(context.Context, *GetAllGuestsRequest) (*GetAllGuestsResponse, error)
	GetGuestByID(context.Context, *GetGuestByIDRequest) (*GetGuestByIDResponse, error)
	UpdateGuest(context.Context, *UpdateGuestRequest) (*UpdateGuestResponse, error)
	AddGuestNote(context.Context, *AddGuestNoteRequest) (*AddGuestNoteResponse, error)
	GetAllGuestFeedback(context.Context, *GetAllGuestFeedbackRequest) (*GetAllGuestFeedbackResponse, error)
	GetGuestUpcomingReservations(context.Context, *GetGuestUpcomingReservationsRequest) (*GetGuestUpcomingReservationsResponse, error)
	GetAllGuestReservations(context.Context, *GetAllGuestReservationsRequest) (*GetAllGuestReservationsResponse, error)
	GetGuestStatistics(context.Context, *GetGuestStatisticsRequest) (*GetGuestStatisticsResponse, error)
	GetGuestSpending(context.Context, *GetGuestSpendingRequest) (*GetGuestSpendingResponse, error)
	GetGuestReservationStatistics(context.Context, *GetGuestReservationStatisticsRequest) (*GetGuestReservationStatisticsResponse, error)
	UpdateGuestNote(context.Context, *UpdateGuestNoteRequest) (*UpdateGuestNoteResponse, error)
	DeleteGuestNote(context.Context, *DeleteGuestNoteRequest) (*DeleteGuestNoteResponse, error)
	ImportGuestsFromExcel(context.Context, *ImportGuestsFromExcelRequest) (*ImportGuestsFromExcelResponse, error)
	AddReservationVisitors(context.Context, *AddReservationVisitorsRequest) (*AddReservationVisitorsResponse, error)
	DeleteReservationVisitors(context.Context, *DeleteReservationVisitorsRequest) (*DeleteReservationVisitorsResponse, error)
}

// UnimplementedGuestServer should be embedded to have forward compatible implementations.
type UnimplementedGuestServer struct {
}

func (UnimplementedGuestServer) CreateGuest(context.Context, *CreateGuestRequest) (*CreateGuestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGuest not implemented")
}
func (UnimplementedGuestServer) GetAllGuests(context.Context, *GetAllGuestsRequest) (*GetAllGuestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGuests not implemented")
}
func (UnimplementedGuestServer) GetGuestByID(context.Context, *GetGuestByIDRequest) (*GetGuestByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestByID not implemented")
}
func (UnimplementedGuestServer) UpdateGuest(context.Context, *UpdateGuestRequest) (*UpdateGuestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGuest not implemented")
}
func (UnimplementedGuestServer) AddGuestNote(context.Context, *AddGuestNoteRequest) (*AddGuestNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddGuestNote not implemented")
}
func (UnimplementedGuestServer) GetAllGuestFeedback(context.Context, *GetAllGuestFeedbackRequest) (*GetAllGuestFeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGuestFeedback not implemented")
}
func (UnimplementedGuestServer) GetGuestUpcomingReservations(context.Context, *GetGuestUpcomingReservationsRequest) (*GetGuestUpcomingReservationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestUpcomingReservations not implemented")
}
func (UnimplementedGuestServer) GetAllGuestReservations(context.Context, *GetAllGuestReservationsRequest) (*GetAllGuestReservationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGuestReservations not implemented")
}
func (UnimplementedGuestServer) GetGuestStatistics(context.Context, *GetGuestStatisticsRequest) (*GetGuestStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestStatistics not implemented")
}
func (UnimplementedGuestServer) GetGuestSpending(context.Context, *GetGuestSpendingRequest) (*GetGuestSpendingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestSpending not implemented")
}
func (UnimplementedGuestServer) GetGuestReservationStatistics(context.Context, *GetGuestReservationStatisticsRequest) (*GetGuestReservationStatisticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestReservationStatistics not implemented")
}
func (UnimplementedGuestServer) UpdateGuestNote(context.Context, *UpdateGuestNoteRequest) (*UpdateGuestNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGuestNote not implemented")
}
func (UnimplementedGuestServer) DeleteGuestNote(context.Context, *DeleteGuestNoteRequest) (*DeleteGuestNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGuestNote not implemented")
}
func (UnimplementedGuestServer) ImportGuestsFromExcel(context.Context, *ImportGuestsFromExcelRequest) (*ImportGuestsFromExcelResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ImportGuestsFromExcel not implemented")
}
func (UnimplementedGuestServer) AddReservationVisitors(context.Context, *AddReservationVisitorsRequest) (*AddReservationVisitorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReservationVisitors not implemented")
}
func (UnimplementedGuestServer) DeleteReservationVisitors(context.Context, *DeleteReservationVisitorsRequest) (*DeleteReservationVisitorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReservationVisitors not implemented")
}

// UnsafeGuestServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestServer will
// result in compilation errors.
type UnsafeGuestServer interface {
	mustEmbedUnimplementedGuestServer()
}

func RegisterGuestServer(s grpc.ServiceRegistrar, srv GuestServer) {
	s.RegisterService(&Guest_ServiceDesc, srv)
}

func _Guest_CreateGuest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGuestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).CreateGuest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_CreateGuest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).CreateGuest(ctx, req.(*CreateGuestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetAllGuests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllGuestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetAllGuests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetAllGuests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetAllGuests(ctx, req.(*GetAllGuestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetGuestByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetGuestByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetGuestByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetGuestByID(ctx, req.(*GetGuestByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_UpdateGuest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGuestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).UpdateGuest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_UpdateGuest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).UpdateGuest(ctx, req.(*UpdateGuestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_AddGuestNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddGuestNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).AddGuestNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_AddGuestNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).AddGuestNote(ctx, req.(*AddGuestNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetAllGuestFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllGuestFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetAllGuestFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetAllGuestFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetAllGuestFeedback(ctx, req.(*GetAllGuestFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetGuestUpcomingReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestUpcomingReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetGuestUpcomingReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetGuestUpcomingReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetGuestUpcomingReservations(ctx, req.(*GetGuestUpcomingReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetAllGuestReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllGuestReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetAllGuestReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetAllGuestReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetAllGuestReservations(ctx, req.(*GetAllGuestReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetGuestStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetGuestStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetGuestStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetGuestStatistics(ctx, req.(*GetGuestStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetGuestSpending_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestSpendingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetGuestSpending(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetGuestSpending_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetGuestSpending(ctx, req.(*GetGuestSpendingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_GetGuestReservationStatistics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestReservationStatisticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).GetGuestReservationStatistics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_GetGuestReservationStatistics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).GetGuestReservationStatistics(ctx, req.(*GetGuestReservationStatisticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_UpdateGuestNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGuestNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).UpdateGuestNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_UpdateGuestNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).UpdateGuestNote(ctx, req.(*UpdateGuestNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_DeleteGuestNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGuestNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).DeleteGuestNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_DeleteGuestNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).DeleteGuestNote(ctx, req.(*DeleteGuestNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_ImportGuestsFromExcel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImportGuestsFromExcelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).ImportGuestsFromExcel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_ImportGuestsFromExcel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).ImportGuestsFromExcel(ctx, req.(*ImportGuestsFromExcelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_AddReservationVisitors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReservationVisitorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).AddReservationVisitors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_AddReservationVisitors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).AddReservationVisitors(ctx, req.(*AddReservationVisitorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Guest_DeleteReservationVisitors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationVisitorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestServer).DeleteReservationVisitors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Guest_DeleteReservationVisitors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestServer).DeleteReservationVisitors(ctx, req.(*DeleteReservationVisitorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Guest_ServiceDesc is the grpc.ServiceDesc for Guest service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Guest_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.guest",
	HandlerType: (*GuestServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateGuest",
			Handler:    _Guest_CreateGuest_Handler,
		},
		{
			MethodName: "GetAllGuests",
			Handler:    _Guest_GetAllGuests_Handler,
		},
		{
			MethodName: "GetGuestByID",
			Handler:    _Guest_GetGuestByID_Handler,
		},
		{
			MethodName: "UpdateGuest",
			Handler:    _Guest_UpdateGuest_Handler,
		},
		{
			MethodName: "AddGuestNote",
			Handler:    _Guest_AddGuestNote_Handler,
		},
		{
			MethodName: "GetAllGuestFeedback",
			Handler:    _Guest_GetAllGuestFeedback_Handler,
		},
		{
			MethodName: "GetGuestUpcomingReservations",
			Handler:    _Guest_GetGuestUpcomingReservations_Handler,
		},
		{
			MethodName: "GetAllGuestReservations",
			Handler:    _Guest_GetAllGuestReservations_Handler,
		},
		{
			MethodName: "GetGuestStatistics",
			Handler:    _Guest_GetGuestStatistics_Handler,
		},
		{
			MethodName: "GetGuestSpending",
			Handler:    _Guest_GetGuestSpending_Handler,
		},
		{
			MethodName: "GetGuestReservationStatistics",
			Handler:    _Guest_GetGuestReservationStatistics_Handler,
		},
		{
			MethodName: "UpdateGuestNote",
			Handler:    _Guest_UpdateGuestNote_Handler,
		},
		{
			MethodName: "DeleteGuestNote",
			Handler:    _Guest_DeleteGuestNote_Handler,
		},
		{
			MethodName: "ImportGuestsFromExcel",
			Handler:    _Guest_ImportGuestsFromExcel_Handler,
		},
		{
			MethodName: "AddReservationVisitors",
			Handler:    _Guest_AddReservationVisitors_Handler,
		},
		{
			MethodName: "DeleteReservationVisitors",
			Handler:    _Guest_DeleteReservationVisitors_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	Reservation_CreateReservation_FullMethodName                  = "/guest_proto.reservation/CreateReservation"
	Reservation_GetAllReservations_FullMethodName                 = "/guest_proto.reservation/GetAllReservations"
	Reservation_GetReservationByID_FullMethodName                 = "/guest_proto.reservation/GetReservationByID"
	Reservation_UpdateReservation_FullMethodName                  = "/guest_proto.reservation/UpdateReservation"
	Reservation_GetAvailableTimes_FullMethodName                  = "/guest_proto.reservation/GetAvailableTimes"
	Reservation_AddReservationNote_FullMethodName                 = "/guest_proto.reservation/AddReservationNote"
	Reservation_GetRealtimeReservations_FullMethodName            = "/guest_proto.reservation/GetRealtimeReservations"
	Reservation_UpdateReservationTable_FullMethodName             = "/guest_proto.reservation/UpdateReservationTable"
	Reservation_DeleteReservation_FullMethodName                  = "/guest_proto.reservation/DeleteReservation"
	Reservation_UpdateReservationNote_FullMethodName              = "/guest_proto.reservation/UpdateReservationNote"
	Reservation_GetReservationOrderByReservationID_FullMethodName = "/guest_proto.reservation/GetReservationOrderByReservationID"
	Reservation_DeleteReservationNote_FullMethodName              = "/guest_proto.reservation/DeleteReservationNote"
	Reservation_GetReservationsCoverFlow_FullMethodName           = "/guest_proto.reservation/GetReservationsCoverFlow"
	Reservation_UpdateReservationFromWebhook_FullMethodName       = "/guest_proto.reservation/UpdateReservationFromWebhook"
	Reservation_GetAllBookedVia_FullMethodName                    = "/guest_proto.reservation/GetAllBookedVia"
	Reservation_RequestReservationWebhook_FullMethodName          = "/guest_proto.reservation/RequestReservationWebhook"
)

// ReservationClient is the client API for Reservation service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationClient interface {
	CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationResponse, error)
	GetAllReservations(ctx context.Context, in *GetAllReservationsRequest, opts ...grpc.CallOption) (*GetAllReservationsResponse, error)
	GetReservationByID(ctx context.Context, in *GetReservationByIDRequest, opts ...grpc.CallOption) (*GetReservationByIDResponse, error)
	UpdateReservation(ctx context.Context, in *UpdateReservationRequest, opts ...grpc.CallOption) (*UpdateReservationResponse, error)
	GetAvailableTimes(ctx context.Context, in *GetAvailableTimesRequest, opts ...grpc.CallOption) (*GetAvailableTimesResponse, error)
	AddReservationNote(ctx context.Context, in *AddReservationNoteRequest, opts ...grpc.CallOption) (*AddReservationNoteResponse, error)
	GetRealtimeReservations(ctx context.Context, in *GetRealtimeReservationsRequest, opts ...grpc.CallOption) (Reservation_GetRealtimeReservationsClient, error)
	UpdateReservationTable(ctx context.Context, in *UpdateReservationTableRequest, opts ...grpc.CallOption) (*UpdateReservationTableResponse, error)
	DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationResponse, error)
	UpdateReservationNote(ctx context.Context, in *UpdateReservationNoteRequest, opts ...grpc.CallOption) (*UpdateReservationNoteResponse, error)
	GetReservationOrderByReservationID(ctx context.Context, in *GetReservationOrderByReservationIDRequest, opts ...grpc.CallOption) (*GetReservationOrderByReservationIDResponse, error)
	DeleteReservationNote(ctx context.Context, in *DeleteReservationNoteRequest, opts ...grpc.CallOption) (*DeleteReservationNoteResponse, error)
	GetReservationsCoverFlow(ctx context.Context, in *GetReservationsCoverFlowRequest, opts ...grpc.CallOption) (*GetReservationsCoverFlowResponse, error)
	UpdateReservationFromWebhook(ctx context.Context, in *UpdateReservationFromWebhookRequest, opts ...grpc.CallOption) (*UpdateReservationFromWebhookResponse, error)
	GetAllBookedVia(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllBookedViaResponse, error)
	RequestReservationWebhook(ctx context.Context, in *RequestReservationWebhookRequest, opts ...grpc.CallOption) (*RequestReservationWebhookResponse, error)
}

type reservationClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationClient(cc grpc.ClientConnInterface) ReservationClient {
	return &reservationClient{cc}
}

func (c *reservationClient) CreateReservation(ctx context.Context, in *CreateReservationRequest, opts ...grpc.CallOption) (*CreateReservationResponse, error) {
	out := new(CreateReservationResponse)
	err := c.cc.Invoke(ctx, Reservation_CreateReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetAllReservations(ctx context.Context, in *GetAllReservationsRequest, opts ...grpc.CallOption) (*GetAllReservationsResponse, error) {
	out := new(GetAllReservationsResponse)
	err := c.cc.Invoke(ctx, Reservation_GetAllReservations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetReservationByID(ctx context.Context, in *GetReservationByIDRequest, opts ...grpc.CallOption) (*GetReservationByIDResponse, error) {
	out := new(GetReservationByIDResponse)
	err := c.cc.Invoke(ctx, Reservation_GetReservationByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) UpdateReservation(ctx context.Context, in *UpdateReservationRequest, opts ...grpc.CallOption) (*UpdateReservationResponse, error) {
	out := new(UpdateReservationResponse)
	err := c.cc.Invoke(ctx, Reservation_UpdateReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetAvailableTimes(ctx context.Context, in *GetAvailableTimesRequest, opts ...grpc.CallOption) (*GetAvailableTimesResponse, error) {
	out := new(GetAvailableTimesResponse)
	err := c.cc.Invoke(ctx, Reservation_GetAvailableTimes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) AddReservationNote(ctx context.Context, in *AddReservationNoteRequest, opts ...grpc.CallOption) (*AddReservationNoteResponse, error) {
	out := new(AddReservationNoteResponse)
	err := c.cc.Invoke(ctx, Reservation_AddReservationNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetRealtimeReservations(ctx context.Context, in *GetRealtimeReservationsRequest, opts ...grpc.CallOption) (Reservation_GetRealtimeReservationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Reservation_ServiceDesc.Streams[0], Reservation_GetRealtimeReservations_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &reservationGetRealtimeReservationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Reservation_GetRealtimeReservationsClient interface {
	Recv() (*GetReservationByIDResponse, error)
	grpc.ClientStream
}

type reservationGetRealtimeReservationsClient struct {
	grpc.ClientStream
}

func (x *reservationGetRealtimeReservationsClient) Recv() (*GetReservationByIDResponse, error) {
	m := new(GetReservationByIDResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *reservationClient) UpdateReservationTable(ctx context.Context, in *UpdateReservationTableRequest, opts ...grpc.CallOption) (*UpdateReservationTableResponse, error) {
	out := new(UpdateReservationTableResponse)
	err := c.cc.Invoke(ctx, Reservation_UpdateReservationTable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) DeleteReservation(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*DeleteReservationResponse, error) {
	out := new(DeleteReservationResponse)
	err := c.cc.Invoke(ctx, Reservation_DeleteReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) UpdateReservationNote(ctx context.Context, in *UpdateReservationNoteRequest, opts ...grpc.CallOption) (*UpdateReservationNoteResponse, error) {
	out := new(UpdateReservationNoteResponse)
	err := c.cc.Invoke(ctx, Reservation_UpdateReservationNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetReservationOrderByReservationID(ctx context.Context, in *GetReservationOrderByReservationIDRequest, opts ...grpc.CallOption) (*GetReservationOrderByReservationIDResponse, error) {
	out := new(GetReservationOrderByReservationIDResponse)
	err := c.cc.Invoke(ctx, Reservation_GetReservationOrderByReservationID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) DeleteReservationNote(ctx context.Context, in *DeleteReservationNoteRequest, opts ...grpc.CallOption) (*DeleteReservationNoteResponse, error) {
	out := new(DeleteReservationNoteResponse)
	err := c.cc.Invoke(ctx, Reservation_DeleteReservationNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetReservationsCoverFlow(ctx context.Context, in *GetReservationsCoverFlowRequest, opts ...grpc.CallOption) (*GetReservationsCoverFlowResponse, error) {
	out := new(GetReservationsCoverFlowResponse)
	err := c.cc.Invoke(ctx, Reservation_GetReservationsCoverFlow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) UpdateReservationFromWebhook(ctx context.Context, in *UpdateReservationFromWebhookRequest, opts ...grpc.CallOption) (*UpdateReservationFromWebhookResponse, error) {
	out := new(UpdateReservationFromWebhookResponse)
	err := c.cc.Invoke(ctx, Reservation_UpdateReservationFromWebhook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) GetAllBookedVia(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllBookedViaResponse, error) {
	out := new(GetAllBookedViaResponse)
	err := c.cc.Invoke(ctx, Reservation_GetAllBookedVia_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationClient) RequestReservationWebhook(ctx context.Context, in *RequestReservationWebhookRequest, opts ...grpc.CallOption) (*RequestReservationWebhookResponse, error) {
	out := new(RequestReservationWebhookResponse)
	err := c.cc.Invoke(ctx, Reservation_RequestReservationWebhook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationServer is the server API for Reservation service.
// All implementations should embed UnimplementedReservationServer
// for forward compatibility
type ReservationServer interface {
	CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationResponse, error)
	GetAllReservations(context.Context, *GetAllReservationsRequest) (*GetAllReservationsResponse, error)
	GetReservationByID(context.Context, *GetReservationByIDRequest) (*GetReservationByIDResponse, error)
	UpdateReservation(context.Context, *UpdateReservationRequest) (*UpdateReservationResponse, error)
	GetAvailableTimes(context.Context, *GetAvailableTimesRequest) (*GetAvailableTimesResponse, error)
	AddReservationNote(context.Context, *AddReservationNoteRequest) (*AddReservationNoteResponse, error)
	GetRealtimeReservations(*GetRealtimeReservationsRequest, Reservation_GetRealtimeReservationsServer) error
	UpdateReservationTable(context.Context, *UpdateReservationTableRequest) (*UpdateReservationTableResponse, error)
	DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationResponse, error)
	UpdateReservationNote(context.Context, *UpdateReservationNoteRequest) (*UpdateReservationNoteResponse, error)
	GetReservationOrderByReservationID(context.Context, *GetReservationOrderByReservationIDRequest) (*GetReservationOrderByReservationIDResponse, error)
	DeleteReservationNote(context.Context, *DeleteReservationNoteRequest) (*DeleteReservationNoteResponse, error)
	GetReservationsCoverFlow(context.Context, *GetReservationsCoverFlowRequest) (*GetReservationsCoverFlowResponse, error)
	UpdateReservationFromWebhook(context.Context, *UpdateReservationFromWebhookRequest) (*UpdateReservationFromWebhookResponse, error)
	GetAllBookedVia(context.Context, *emptypb.Empty) (*GetAllBookedViaResponse, error)
	RequestReservationWebhook(context.Context, *RequestReservationWebhookRequest) (*RequestReservationWebhookResponse, error)
}

// UnimplementedReservationServer should be embedded to have forward compatible implementations.
type UnimplementedReservationServer struct {
}

func (UnimplementedReservationServer) CreateReservation(context.Context, *CreateReservationRequest) (*CreateReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservation not implemented")
}
func (UnimplementedReservationServer) GetAllReservations(context.Context, *GetAllReservationsRequest) (*GetAllReservationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservations not implemented")
}
func (UnimplementedReservationServer) GetReservationByID(context.Context, *GetReservationByIDRequest) (*GetReservationByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReservationByID not implemented")
}
func (UnimplementedReservationServer) UpdateReservation(context.Context, *UpdateReservationRequest) (*UpdateReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservation not implemented")
}
func (UnimplementedReservationServer) GetAvailableTimes(context.Context, *GetAvailableTimesRequest) (*GetAvailableTimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableTimes not implemented")
}
func (UnimplementedReservationServer) AddReservationNote(context.Context, *AddReservationNoteRequest) (*AddReservationNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReservationNote not implemented")
}
func (UnimplementedReservationServer) GetRealtimeReservations(*GetRealtimeReservationsRequest, Reservation_GetRealtimeReservationsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRealtimeReservations not implemented")
}
func (UnimplementedReservationServer) UpdateReservationTable(context.Context, *UpdateReservationTableRequest) (*UpdateReservationTableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservationTable not implemented")
}
func (UnimplementedReservationServer) DeleteReservation(context.Context, *DeleteReservationRequest) (*DeleteReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReservation not implemented")
}
func (UnimplementedReservationServer) UpdateReservationNote(context.Context, *UpdateReservationNoteRequest) (*UpdateReservationNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservationNote not implemented")
}
func (UnimplementedReservationServer) GetReservationOrderByReservationID(context.Context, *GetReservationOrderByReservationIDRequest) (*GetReservationOrderByReservationIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReservationOrderByReservationID not implemented")
}
func (UnimplementedReservationServer) DeleteReservationNote(context.Context, *DeleteReservationNoteRequest) (*DeleteReservationNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteReservationNote not implemented")
}
func (UnimplementedReservationServer) GetReservationsCoverFlow(context.Context, *GetReservationsCoverFlowRequest) (*GetReservationsCoverFlowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReservationsCoverFlow not implemented")
}
func (UnimplementedReservationServer) UpdateReservationFromWebhook(context.Context, *UpdateReservationFromWebhookRequest) (*UpdateReservationFromWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservationFromWebhook not implemented")
}
func (UnimplementedReservationServer) GetAllBookedVia(context.Context, *emptypb.Empty) (*GetAllBookedViaResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllBookedVia not implemented")
}
func (UnimplementedReservationServer) RequestReservationWebhook(context.Context, *RequestReservationWebhookRequest) (*RequestReservationWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestReservationWebhook not implemented")
}

// UnsafeReservationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationServer will
// result in compilation errors.
type UnsafeReservationServer interface {
	mustEmbedUnimplementedReservationServer()
}

func RegisterReservationServer(s grpc.ServiceRegistrar, srv ReservationServer) {
	s.RegisterService(&Reservation_ServiceDesc, srv)
}

func _Reservation_CreateReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).CreateReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_CreateReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).CreateReservation(ctx, req.(*CreateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetAllReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetAllReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetAllReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetAllReservations(ctx, req.(*GetAllReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetReservationByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetReservationByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetReservationByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetReservationByID(ctx, req.(*GetReservationByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_UpdateReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).UpdateReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_UpdateReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).UpdateReservation(ctx, req.(*UpdateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetAvailableTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAvailableTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetAvailableTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetAvailableTimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetAvailableTimes(ctx, req.(*GetAvailableTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_AddReservationNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReservationNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).AddReservationNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_AddReservationNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).AddReservationNote(ctx, req.(*AddReservationNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetRealtimeReservations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetRealtimeReservationsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReservationServer).GetRealtimeReservations(m, &reservationGetRealtimeReservationsServer{stream})
}

type Reservation_GetRealtimeReservationsServer interface {
	Send(*GetReservationByIDResponse) error
	grpc.ServerStream
}

type reservationGetRealtimeReservationsServer struct {
	grpc.ServerStream
}

func (x *reservationGetRealtimeReservationsServer) Send(m *GetReservationByIDResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Reservation_UpdateReservationTable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationTableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).UpdateReservationTable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_UpdateReservationTable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).UpdateReservationTable(ctx, req.(*UpdateReservationTableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_DeleteReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).DeleteReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_DeleteReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).DeleteReservation(ctx, req.(*DeleteReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_UpdateReservationNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).UpdateReservationNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_UpdateReservationNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).UpdateReservationNote(ctx, req.(*UpdateReservationNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetReservationOrderByReservationID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationOrderByReservationIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetReservationOrderByReservationID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetReservationOrderByReservationID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetReservationOrderByReservationID(ctx, req.(*GetReservationOrderByReservationIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_DeleteReservationNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).DeleteReservationNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_DeleteReservationNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).DeleteReservationNote(ctx, req.(*DeleteReservationNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetReservationsCoverFlow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationsCoverFlowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetReservationsCoverFlow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetReservationsCoverFlow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetReservationsCoverFlow(ctx, req.(*GetReservationsCoverFlowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_UpdateReservationFromWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationFromWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).UpdateReservationFromWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_UpdateReservationFromWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).UpdateReservationFromWebhook(ctx, req.(*UpdateReservationFromWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_GetAllBookedVia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).GetAllBookedVia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_GetAllBookedVia_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).GetAllBookedVia(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservation_RequestReservationWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestReservationWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationServer).RequestReservationWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservation_RequestReservationWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationServer).RequestReservationWebhook(ctx, req.(*RequestReservationWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Reservation_ServiceDesc is the grpc.ServiceDesc for Reservation service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Reservation_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservation",
	HandlerType: (*ReservationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReservation",
			Handler:    _Reservation_CreateReservation_Handler,
		},
		{
			MethodName: "GetAllReservations",
			Handler:    _Reservation_GetAllReservations_Handler,
		},
		{
			MethodName: "GetReservationByID",
			Handler:    _Reservation_GetReservationByID_Handler,
		},
		{
			MethodName: "UpdateReservation",
			Handler:    _Reservation_UpdateReservation_Handler,
		},
		{
			MethodName: "GetAvailableTimes",
			Handler:    _Reservation_GetAvailableTimes_Handler,
		},
		{
			MethodName: "AddReservationNote",
			Handler:    _Reservation_AddReservationNote_Handler,
		},
		{
			MethodName: "UpdateReservationTable",
			Handler:    _Reservation_UpdateReservationTable_Handler,
		},
		{
			MethodName: "DeleteReservation",
			Handler:    _Reservation_DeleteReservation_Handler,
		},
		{
			MethodName: "UpdateReservationNote",
			Handler:    _Reservation_UpdateReservationNote_Handler,
		},
		{
			MethodName: "GetReservationOrderByReservationID",
			Handler:    _Reservation_GetReservationOrderByReservationID_Handler,
		},
		{
			MethodName: "DeleteReservationNote",
			Handler:    _Reservation_DeleteReservationNote_Handler,
		},
		{
			MethodName: "GetReservationsCoverFlow",
			Handler:    _Reservation_GetReservationsCoverFlow_Handler,
		},
		{
			MethodName: "UpdateReservationFromWebhook",
			Handler:    _Reservation_UpdateReservationFromWebhook_Handler,
		},
		{
			MethodName: "GetAllBookedVia",
			Handler:    _Reservation_GetAllBookedVia_Handler,
		},
		{
			MethodName: "RequestReservationWebhook",
			Handler:    _Reservation_RequestReservationWebhook_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRealtimeReservations",
			Handler:       _Reservation_GetRealtimeReservations_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/guest_service.proto",
}

const (
	GuestLog_GetAllGuestLogs_FullMethodName = "/guest_proto.guestLog/GetAllGuestLogs"
)

// GuestLogClient is the client API for GuestLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GuestLogClient interface {
	GetAllGuestLogs(ctx context.Context, in *GetAllGuestLogsRequest, opts ...grpc.CallOption) (*GetAllGuestLogsResponse, error)
}

type guestLogClient struct {
	cc grpc.ClientConnInterface
}

func NewGuestLogClient(cc grpc.ClientConnInterface) GuestLogClient {
	return &guestLogClient{cc}
}

func (c *guestLogClient) GetAllGuestLogs(ctx context.Context, in *GetAllGuestLogsRequest, opts ...grpc.CallOption) (*GetAllGuestLogsResponse, error) {
	out := new(GetAllGuestLogsResponse)
	err := c.cc.Invoke(ctx, GuestLog_GetAllGuestLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GuestLogServer is the server API for GuestLog service.
// All implementations should embed UnimplementedGuestLogServer
// for forward compatibility
type GuestLogServer interface {
	GetAllGuestLogs(context.Context, *GetAllGuestLogsRequest) (*GetAllGuestLogsResponse, error)
}

// UnimplementedGuestLogServer should be embedded to have forward compatible implementations.
type UnimplementedGuestLogServer struct {
}

func (UnimplementedGuestLogServer) GetAllGuestLogs(context.Context, *GetAllGuestLogsRequest) (*GetAllGuestLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllGuestLogs not implemented")
}

// UnsafeGuestLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GuestLogServer will
// result in compilation errors.
type UnsafeGuestLogServer interface {
	mustEmbedUnimplementedGuestLogServer()
}

func RegisterGuestLogServer(s grpc.ServiceRegistrar, srv GuestLogServer) {
	s.RegisterService(&GuestLog_ServiceDesc, srv)
}

func _GuestLog_GetAllGuestLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllGuestLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GuestLogServer).GetAllGuestLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GuestLog_GetAllGuestLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GuestLogServer).GetAllGuestLogs(ctx, req.(*GetAllGuestLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GuestLog_ServiceDesc is the grpc.ServiceDesc for GuestLog service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GuestLog_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.guestLog",
	HandlerType: (*GuestLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllGuestLogs",
			Handler:    _GuestLog_GetAllGuestLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationLog_GetAllReservationLogs_FullMethodName         = "/guest_proto.reservationLog/GetAllReservationLogs"
	ReservationLog_GetAllReservationWaitlistLogs_FullMethodName = "/guest_proto.reservationLog/GetAllReservationWaitlistLogs"
)

// ReservationLogClient is the client API for ReservationLog service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationLogClient interface {
	GetAllReservationLogs(ctx context.Context, in *GetAllReservationLogsRequest, opts ...grpc.CallOption) (*GetAllReservationLogsResponse, error)
	GetAllReservationWaitlistLogs(ctx context.Context, in *GetAllReservationWaitlistLogsRequest, opts ...grpc.CallOption) (*GetAllReservationWaitlistLogsResponse, error)
}

type reservationLogClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationLogClient(cc grpc.ClientConnInterface) ReservationLogClient {
	return &reservationLogClient{cc}
}

func (c *reservationLogClient) GetAllReservationLogs(ctx context.Context, in *GetAllReservationLogsRequest, opts ...grpc.CallOption) (*GetAllReservationLogsResponse, error) {
	out := new(GetAllReservationLogsResponse)
	err := c.cc.Invoke(ctx, ReservationLog_GetAllReservationLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationLogClient) GetAllReservationWaitlistLogs(ctx context.Context, in *GetAllReservationWaitlistLogsRequest, opts ...grpc.CallOption) (*GetAllReservationWaitlistLogsResponse, error) {
	out := new(GetAllReservationWaitlistLogsResponse)
	err := c.cc.Invoke(ctx, ReservationLog_GetAllReservationWaitlistLogs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationLogServer is the server API for ReservationLog service.
// All implementations should embed UnimplementedReservationLogServer
// for forward compatibility
type ReservationLogServer interface {
	GetAllReservationLogs(context.Context, *GetAllReservationLogsRequest) (*GetAllReservationLogsResponse, error)
	GetAllReservationWaitlistLogs(context.Context, *GetAllReservationWaitlistLogsRequest) (*GetAllReservationWaitlistLogsResponse, error)
}

// UnimplementedReservationLogServer should be embedded to have forward compatible implementations.
type UnimplementedReservationLogServer struct {
}

func (UnimplementedReservationLogServer) GetAllReservationLogs(context.Context, *GetAllReservationLogsRequest) (*GetAllReservationLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationLogs not implemented")
}
func (UnimplementedReservationLogServer) GetAllReservationWaitlistLogs(context.Context, *GetAllReservationWaitlistLogsRequest) (*GetAllReservationWaitlistLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationWaitlistLogs not implemented")
}

// UnsafeReservationLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationLogServer will
// result in compilation errors.
type UnsafeReservationLogServer interface {
	mustEmbedUnimplementedReservationLogServer()
}

func RegisterReservationLogServer(s grpc.ServiceRegistrar, srv ReservationLogServer) {
	s.RegisterService(&ReservationLog_ServiceDesc, srv)
}

func _ReservationLog_GetAllReservationLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationLogServer).GetAllReservationLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationLog_GetAllReservationLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationLogServer).GetAllReservationLogs(ctx, req.(*GetAllReservationLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationLog_GetAllReservationWaitlistLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationWaitlistLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationLogServer).GetAllReservationWaitlistLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationLog_GetAllReservationWaitlistLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationLogServer).GetAllReservationWaitlistLogs(ctx, req.(*GetAllReservationWaitlistLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationLog_ServiceDesc is the grpc.ServiceDesc for ReservationLog service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationLog_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationLog",
	HandlerType: (*ReservationLogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllReservationLogs",
			Handler:    _ReservationLog_GetAllReservationLogs_Handler,
		},
		{
			MethodName: "GetAllReservationWaitlistLogs",
			Handler:    _ReservationLog_GetAllReservationWaitlistLogs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationSpecialOccasion_GetAllSpecialOccasions_FullMethodName       = "/guest_proto.reservationSpecialOccasion/GetAllSpecialOccasions"
	ReservationSpecialOccasion_GetWidgetAllSpecialOccasions_FullMethodName = "/guest_proto.reservationSpecialOccasion/GetWidgetAllSpecialOccasions"
)

// ReservationSpecialOccasionClient is the client API for ReservationSpecialOccasion service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationSpecialOccasionClient interface {
	GetAllSpecialOccasions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllSpecialOccasionsResponse, error)
	GetWidgetAllSpecialOccasions(ctx context.Context, in *GetWidgetAllSpecialOccasionsRequest, opts ...grpc.CallOption) (*GetAllSpecialOccasionsResponse, error)
}

type reservationSpecialOccasionClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationSpecialOccasionClient(cc grpc.ClientConnInterface) ReservationSpecialOccasionClient {
	return &reservationSpecialOccasionClient{cc}
}

func (c *reservationSpecialOccasionClient) GetAllSpecialOccasions(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllSpecialOccasionsResponse, error) {
	out := new(GetAllSpecialOccasionsResponse)
	err := c.cc.Invoke(ctx, ReservationSpecialOccasion_GetAllSpecialOccasions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSpecialOccasionClient) GetWidgetAllSpecialOccasions(ctx context.Context, in *GetWidgetAllSpecialOccasionsRequest, opts ...grpc.CallOption) (*GetAllSpecialOccasionsResponse, error) {
	out := new(GetAllSpecialOccasionsResponse)
	err := c.cc.Invoke(ctx, ReservationSpecialOccasion_GetWidgetAllSpecialOccasions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationSpecialOccasionServer is the server API for ReservationSpecialOccasion service.
// All implementations should embed UnimplementedReservationSpecialOccasionServer
// for forward compatibility
type ReservationSpecialOccasionServer interface {
	GetAllSpecialOccasions(context.Context, *emptypb.Empty) (*GetAllSpecialOccasionsResponse, error)
	GetWidgetAllSpecialOccasions(context.Context, *GetWidgetAllSpecialOccasionsRequest) (*GetAllSpecialOccasionsResponse, error)
}

// UnimplementedReservationSpecialOccasionServer should be embedded to have forward compatible implementations.
type UnimplementedReservationSpecialOccasionServer struct {
}

func (UnimplementedReservationSpecialOccasionServer) GetAllSpecialOccasions(context.Context, *emptypb.Empty) (*GetAllSpecialOccasionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllSpecialOccasions not implemented")
}
func (UnimplementedReservationSpecialOccasionServer) GetWidgetAllSpecialOccasions(context.Context, *GetWidgetAllSpecialOccasionsRequest) (*GetAllSpecialOccasionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWidgetAllSpecialOccasions not implemented")
}

// UnsafeReservationSpecialOccasionServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationSpecialOccasionServer will
// result in compilation errors.
type UnsafeReservationSpecialOccasionServer interface {
	mustEmbedUnimplementedReservationSpecialOccasionServer()
}

func RegisterReservationSpecialOccasionServer(s grpc.ServiceRegistrar, srv ReservationSpecialOccasionServer) {
	s.RegisterService(&ReservationSpecialOccasion_ServiceDesc, srv)
}

func _ReservationSpecialOccasion_GetAllSpecialOccasions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSpecialOccasionServer).GetAllSpecialOccasions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSpecialOccasion_GetAllSpecialOccasions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSpecialOccasionServer).GetAllSpecialOccasions(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSpecialOccasion_GetWidgetAllSpecialOccasions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWidgetAllSpecialOccasionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSpecialOccasionServer).GetWidgetAllSpecialOccasions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSpecialOccasion_GetWidgetAllSpecialOccasions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSpecialOccasionServer).GetWidgetAllSpecialOccasions(ctx, req.(*GetWidgetAllSpecialOccasionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationSpecialOccasion_ServiceDesc is the grpc.ServiceDesc for ReservationSpecialOccasion service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationSpecialOccasion_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationSpecialOccasion",
	HandlerType: (*ReservationSpecialOccasionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllSpecialOccasions",
			Handler:    _ReservationSpecialOccasion_GetAllSpecialOccasions_Handler,
		},
		{
			MethodName: "GetWidgetAllSpecialOccasions",
			Handler:    _ReservationSpecialOccasion_GetWidgetAllSpecialOccasions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationFeedback_CreateReservationFeedback_FullMethodName         = "/guest_proto.reservationFeedback/CreateReservationFeedback"
	ReservationFeedback_GetAllReservationsFeedbacks_FullMethodName       = "/guest_proto.reservationFeedback/GetAllReservationsFeedbacks"
	ReservationFeedback_GetReservationFeedbackByID_FullMethodName        = "/guest_proto.reservationFeedback/GetReservationFeedbackByID"
	ReservationFeedback_UpdateReservationFeedback_FullMethodName         = "/guest_proto.reservationFeedback/UpdateReservationFeedback"
	ReservationFeedback_GetAllReservationFeedbackSections_FullMethodName = "/guest_proto.reservationFeedback/GetAllReservationFeedbackSections"
)

// ReservationFeedbackClient is the client API for ReservationFeedback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationFeedbackClient interface {
	CreateReservationFeedback(ctx context.Context, in *CreateReservationFeedbackRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackResponse, error)
	GetAllReservationsFeedbacks(ctx context.Context, in *GetAllReservationsFeedbacksRequest, opts ...grpc.CallOption) (*GetAllReservationsFeedbacksResponse, error)
	GetReservationFeedbackByID(ctx context.Context, in *GetReservationFeedbackByIDRequest, opts ...grpc.CallOption) (*GetReservationFeedbackByIDResponse, error)
	UpdateReservationFeedback(ctx context.Context, in *UpdateReservationFeedbackRequest, opts ...grpc.CallOption) (*UpdateReservationFeedbackResponse, error)
	GetAllReservationFeedbackSections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllReservationsFeedbackSectionsResponse, error)
}

type reservationFeedbackClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationFeedbackClient(cc grpc.ClientConnInterface) ReservationFeedbackClient {
	return &reservationFeedbackClient{cc}
}

func (c *reservationFeedbackClient) CreateReservationFeedback(ctx context.Context, in *CreateReservationFeedbackRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackResponse, error) {
	out := new(CreateReservationFeedbackResponse)
	err := c.cc.Invoke(ctx, ReservationFeedback_CreateReservationFeedback_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackClient) GetAllReservationsFeedbacks(ctx context.Context, in *GetAllReservationsFeedbacksRequest, opts ...grpc.CallOption) (*GetAllReservationsFeedbacksResponse, error) {
	out := new(GetAllReservationsFeedbacksResponse)
	err := c.cc.Invoke(ctx, ReservationFeedback_GetAllReservationsFeedbacks_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackClient) GetReservationFeedbackByID(ctx context.Context, in *GetReservationFeedbackByIDRequest, opts ...grpc.CallOption) (*GetReservationFeedbackByIDResponse, error) {
	out := new(GetReservationFeedbackByIDResponse)
	err := c.cc.Invoke(ctx, ReservationFeedback_GetReservationFeedbackByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackClient) UpdateReservationFeedback(ctx context.Context, in *UpdateReservationFeedbackRequest, opts ...grpc.CallOption) (*UpdateReservationFeedbackResponse, error) {
	out := new(UpdateReservationFeedbackResponse)
	err := c.cc.Invoke(ctx, ReservationFeedback_UpdateReservationFeedback_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackClient) GetAllReservationFeedbackSections(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*GetAllReservationsFeedbackSectionsResponse, error) {
	out := new(GetAllReservationsFeedbackSectionsResponse)
	err := c.cc.Invoke(ctx, ReservationFeedback_GetAllReservationFeedbackSections_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationFeedbackServer is the server API for ReservationFeedback service.
// All implementations should embed UnimplementedReservationFeedbackServer
// for forward compatibility
type ReservationFeedbackServer interface {
	CreateReservationFeedback(context.Context, *CreateReservationFeedbackRequest) (*CreateReservationFeedbackResponse, error)
	GetAllReservationsFeedbacks(context.Context, *GetAllReservationsFeedbacksRequest) (*GetAllReservationsFeedbacksResponse, error)
	GetReservationFeedbackByID(context.Context, *GetReservationFeedbackByIDRequest) (*GetReservationFeedbackByIDResponse, error)
	UpdateReservationFeedback(context.Context, *UpdateReservationFeedbackRequest) (*UpdateReservationFeedbackResponse, error)
	GetAllReservationFeedbackSections(context.Context, *emptypb.Empty) (*GetAllReservationsFeedbackSectionsResponse, error)
}

// UnimplementedReservationFeedbackServer should be embedded to have forward compatible implementations.
type UnimplementedReservationFeedbackServer struct {
}

func (UnimplementedReservationFeedbackServer) CreateReservationFeedback(context.Context, *CreateReservationFeedbackRequest) (*CreateReservationFeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservationFeedback not implemented")
}
func (UnimplementedReservationFeedbackServer) GetAllReservationsFeedbacks(context.Context, *GetAllReservationsFeedbacksRequest) (*GetAllReservationsFeedbacksResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationsFeedbacks not implemented")
}
func (UnimplementedReservationFeedbackServer) GetReservationFeedbackByID(context.Context, *GetReservationFeedbackByIDRequest) (*GetReservationFeedbackByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReservationFeedbackByID not implemented")
}
func (UnimplementedReservationFeedbackServer) UpdateReservationFeedback(context.Context, *UpdateReservationFeedbackRequest) (*UpdateReservationFeedbackResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservationFeedback not implemented")
}
func (UnimplementedReservationFeedbackServer) GetAllReservationFeedbackSections(context.Context, *emptypb.Empty) (*GetAllReservationsFeedbackSectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationFeedbackSections not implemented")
}

// UnsafeReservationFeedbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationFeedbackServer will
// result in compilation errors.
type UnsafeReservationFeedbackServer interface {
	mustEmbedUnimplementedReservationFeedbackServer()
}

func RegisterReservationFeedbackServer(s grpc.ServiceRegistrar, srv ReservationFeedbackServer) {
	s.RegisterService(&ReservationFeedback_ServiceDesc, srv)
}

func _ReservationFeedback_CreateReservationFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackServer).CreateReservationFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedback_CreateReservationFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackServer).CreateReservationFeedback(ctx, req.(*CreateReservationFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedback_GetAllReservationsFeedbacks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationsFeedbacksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackServer).GetAllReservationsFeedbacks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedback_GetAllReservationsFeedbacks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackServer).GetAllReservationsFeedbacks(ctx, req.(*GetAllReservationsFeedbacksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedback_GetReservationFeedbackByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationFeedbackByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackServer).GetReservationFeedbackByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedback_GetReservationFeedbackByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackServer).GetReservationFeedbackByID(ctx, req.(*GetReservationFeedbackByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedback_UpdateReservationFeedback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationFeedbackRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackServer).UpdateReservationFeedback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedback_UpdateReservationFeedback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackServer).UpdateReservationFeedback(ctx, req.(*UpdateReservationFeedbackRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedback_GetAllReservationFeedbackSections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackServer).GetAllReservationFeedbackSections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedback_GetAllReservationFeedbackSections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackServer).GetAllReservationFeedbackSections(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationFeedback_ServiceDesc is the grpc.ServiceDesc for ReservationFeedback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationFeedback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationFeedback",
	HandlerType: (*ReservationFeedbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReservationFeedback",
			Handler:    _ReservationFeedback_CreateReservationFeedback_Handler,
		},
		{
			MethodName: "GetAllReservationsFeedbacks",
			Handler:    _ReservationFeedback_GetAllReservationsFeedbacks_Handler,
		},
		{
			MethodName: "GetReservationFeedbackByID",
			Handler:    _ReservationFeedback_GetReservationFeedbackByID_Handler,
		},
		{
			MethodName: "UpdateReservationFeedback",
			Handler:    _ReservationFeedback_UpdateReservationFeedback_Handler,
		},
		{
			MethodName: "GetAllReservationFeedbackSections",
			Handler:    _ReservationFeedback_GetAllReservationFeedbackSections_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationFeedbackComment_CreateReservationFeedbackComment_FullMethodName  = "/guest_proto.reservationFeedbackComment/CreateReservationFeedbackComment"
	ReservationFeedbackComment_GetAllReservationFeedbackComments_FullMethodName = "/guest_proto.reservationFeedbackComment/GetAllReservationFeedbackComments"
	ReservationFeedbackComment_UpdateReservationFeedbackComment_FullMethodName  = "/guest_proto.reservationFeedbackComment/UpdateReservationFeedbackComment"
	ReservationFeedbackComment_AddReservationFeedbackSolution_FullMethodName    = "/guest_proto.reservationFeedbackComment/AddReservationFeedbackSolution"
)

// ReservationFeedbackCommentClient is the client API for ReservationFeedbackComment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationFeedbackCommentClient interface {
	CreateReservationFeedbackComment(ctx context.Context, in *CreateReservationFeedbackCommentRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackCommentResponse, error)
	GetAllReservationFeedbackComments(ctx context.Context, in *GetAllReservationFeedbackCommentsRequest, opts ...grpc.CallOption) (*GetAllReservationFeedbackCommentsResponse, error)
	UpdateReservationFeedbackComment(ctx context.Context, in *UpdateReservationFeedbackCommentRequest, opts ...grpc.CallOption) (*UpdateReservationFeedbackCommentResponse, error)
	AddReservationFeedbackSolution(ctx context.Context, in *AddReservationFeedbackSolutionRequest, opts ...grpc.CallOption) (*AddReservationFeedbackSolutionResponse, error)
}

type reservationFeedbackCommentClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationFeedbackCommentClient(cc grpc.ClientConnInterface) ReservationFeedbackCommentClient {
	return &reservationFeedbackCommentClient{cc}
}

func (c *reservationFeedbackCommentClient) CreateReservationFeedbackComment(ctx context.Context, in *CreateReservationFeedbackCommentRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackCommentResponse, error) {
	out := new(CreateReservationFeedbackCommentResponse)
	err := c.cc.Invoke(ctx, ReservationFeedbackComment_CreateReservationFeedbackComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackCommentClient) GetAllReservationFeedbackComments(ctx context.Context, in *GetAllReservationFeedbackCommentsRequest, opts ...grpc.CallOption) (*GetAllReservationFeedbackCommentsResponse, error) {
	out := new(GetAllReservationFeedbackCommentsResponse)
	err := c.cc.Invoke(ctx, ReservationFeedbackComment_GetAllReservationFeedbackComments_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackCommentClient) UpdateReservationFeedbackComment(ctx context.Context, in *UpdateReservationFeedbackCommentRequest, opts ...grpc.CallOption) (*UpdateReservationFeedbackCommentResponse, error) {
	out := new(UpdateReservationFeedbackCommentResponse)
	err := c.cc.Invoke(ctx, ReservationFeedbackComment_UpdateReservationFeedbackComment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationFeedbackCommentClient) AddReservationFeedbackSolution(ctx context.Context, in *AddReservationFeedbackSolutionRequest, opts ...grpc.CallOption) (*AddReservationFeedbackSolutionResponse, error) {
	out := new(AddReservationFeedbackSolutionResponse)
	err := c.cc.Invoke(ctx, ReservationFeedbackComment_AddReservationFeedbackSolution_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationFeedbackCommentServer is the server API for ReservationFeedbackComment service.
// All implementations should embed UnimplementedReservationFeedbackCommentServer
// for forward compatibility
type ReservationFeedbackCommentServer interface {
	CreateReservationFeedbackComment(context.Context, *CreateReservationFeedbackCommentRequest) (*CreateReservationFeedbackCommentResponse, error)
	GetAllReservationFeedbackComments(context.Context, *GetAllReservationFeedbackCommentsRequest) (*GetAllReservationFeedbackCommentsResponse, error)
	UpdateReservationFeedbackComment(context.Context, *UpdateReservationFeedbackCommentRequest) (*UpdateReservationFeedbackCommentResponse, error)
	AddReservationFeedbackSolution(context.Context, *AddReservationFeedbackSolutionRequest) (*AddReservationFeedbackSolutionResponse, error)
}

// UnimplementedReservationFeedbackCommentServer should be embedded to have forward compatible implementations.
type UnimplementedReservationFeedbackCommentServer struct {
}

func (UnimplementedReservationFeedbackCommentServer) CreateReservationFeedbackComment(context.Context, *CreateReservationFeedbackCommentRequest) (*CreateReservationFeedbackCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservationFeedbackComment not implemented")
}
func (UnimplementedReservationFeedbackCommentServer) GetAllReservationFeedbackComments(context.Context, *GetAllReservationFeedbackCommentsRequest) (*GetAllReservationFeedbackCommentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationFeedbackComments not implemented")
}
func (UnimplementedReservationFeedbackCommentServer) UpdateReservationFeedbackComment(context.Context, *UpdateReservationFeedbackCommentRequest) (*UpdateReservationFeedbackCommentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReservationFeedbackComment not implemented")
}
func (UnimplementedReservationFeedbackCommentServer) AddReservationFeedbackSolution(context.Context, *AddReservationFeedbackSolutionRequest) (*AddReservationFeedbackSolutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddReservationFeedbackSolution not implemented")
}

// UnsafeReservationFeedbackCommentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationFeedbackCommentServer will
// result in compilation errors.
type UnsafeReservationFeedbackCommentServer interface {
	mustEmbedUnimplementedReservationFeedbackCommentServer()
}

func RegisterReservationFeedbackCommentServer(s grpc.ServiceRegistrar, srv ReservationFeedbackCommentServer) {
	s.RegisterService(&ReservationFeedbackComment_ServiceDesc, srv)
}

func _ReservationFeedbackComment_CreateReservationFeedbackComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationFeedbackCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackCommentServer).CreateReservationFeedbackComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedbackComment_CreateReservationFeedbackComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackCommentServer).CreateReservationFeedbackComment(ctx, req.(*CreateReservationFeedbackCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedbackComment_GetAllReservationFeedbackComments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationFeedbackCommentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackCommentServer).GetAllReservationFeedbackComments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedbackComment_GetAllReservationFeedbackComments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackCommentServer).GetAllReservationFeedbackComments(ctx, req.(*GetAllReservationFeedbackCommentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedbackComment_UpdateReservationFeedbackComment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationFeedbackCommentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackCommentServer).UpdateReservationFeedbackComment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedbackComment_UpdateReservationFeedbackComment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackCommentServer).UpdateReservationFeedbackComment(ctx, req.(*UpdateReservationFeedbackCommentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationFeedbackComment_AddReservationFeedbackSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddReservationFeedbackSolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackCommentServer).AddReservationFeedbackSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedbackComment_AddReservationFeedbackSolution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackCommentServer).AddReservationFeedbackSolution(ctx, req.(*AddReservationFeedbackSolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationFeedbackComment_ServiceDesc is the grpc.ServiceDesc for ReservationFeedbackComment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationFeedbackComment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationFeedbackComment",
	HandlerType: (*ReservationFeedbackCommentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReservationFeedbackComment",
			Handler:    _ReservationFeedbackComment_CreateReservationFeedbackComment_Handler,
		},
		{
			MethodName: "GetAllReservationFeedbackComments",
			Handler:    _ReservationFeedbackComment_GetAllReservationFeedbackComments_Handler,
		},
		{
			MethodName: "UpdateReservationFeedbackComment",
			Handler:    _ReservationFeedbackComment_UpdateReservationFeedbackComment_Handler,
		},
		{
			MethodName: "AddReservationFeedbackSolution",
			Handler:    _ReservationFeedbackComment_AddReservationFeedbackSolution_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationWaitlist_GetAllWaitingReservations_FullMethodName       = "/guest_proto.reservationWaitlist/GetAllWaitingReservations"
	ReservationWaitlist_CreateWaitingReservation_FullMethodName        = "/guest_proto.reservationWaitlist/CreateWaitingReservation"
	ReservationWaitlist_SeatWaitingReservation_FullMethodName          = "/guest_proto.reservationWaitlist/SeatWaitingReservation"
	ReservationWaitlist_GetRealtimeWaitingReservations_FullMethodName  = "/guest_proto.reservationWaitlist/GetRealtimeWaitingReservations"
	ReservationWaitlist_UpdateWaitingReservationDetails_FullMethodName = "/guest_proto.reservationWaitlist/UpdateWaitingReservationDetails"
	ReservationWaitlist_CreateWaitingReservationNote_FullMethodName    = "/guest_proto.reservationWaitlist/CreateWaitingReservationNote"
	ReservationWaitlist_UpdateWaitingReservationNote_FullMethodName    = "/guest_proto.reservationWaitlist/UpdateWaitingReservationNote"
	ReservationWaitlist_CreateDirectInReservation_FullMethodName       = "/guest_proto.reservationWaitlist/CreateDirectInReservation"
)

// ReservationWaitlistClient is the client API for ReservationWaitlist service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationWaitlistClient interface {
	GetAllWaitingReservations(ctx context.Context, in *GetWaitingReservationRequest, opts ...grpc.CallOption) (*GetWaitingReservationsResponse, error)
	CreateWaitingReservation(ctx context.Context, in *CreateWaitingReservationRequest, opts ...grpc.CallOption) (*CreateWaitingReservationResponse, error)
	SeatWaitingReservation(ctx context.Context, in *SeatWaitingReservationRequest, opts ...grpc.CallOption) (*SeatWaitingReservationResponse, error)
	GetRealtimeWaitingReservations(ctx context.Context, in *GetWaitingReservationRequest, opts ...grpc.CallOption) (ReservationWaitlist_GetRealtimeWaitingReservationsClient, error)
	UpdateWaitingReservationDetails(ctx context.Context, in *UpdateWaitingReservationDetailsRequest, opts ...grpc.CallOption) (*UpdateWaitingReservationDetailsResponse, error)
	CreateWaitingReservationNote(ctx context.Context, in *CreateWaitingReservationNoteRequest, opts ...grpc.CallOption) (*CreateWaitingReservationNoteResponse, error)
	UpdateWaitingReservationNote(ctx context.Context, in *UpdateWaitingReservationNoteRequest, opts ...grpc.CallOption) (*UpdateWaitingReservationNoteResponse, error)
	CreateDirectInReservation(ctx context.Context, in *CreateWaitingReservationRequest, opts ...grpc.CallOption) (*CreateReservationResponse, error)
}

type reservationWaitlistClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationWaitlistClient(cc grpc.ClientConnInterface) ReservationWaitlistClient {
	return &reservationWaitlistClient{cc}
}

func (c *reservationWaitlistClient) GetAllWaitingReservations(ctx context.Context, in *GetWaitingReservationRequest, opts ...grpc.CallOption) (*GetWaitingReservationsResponse, error) {
	out := new(GetWaitingReservationsResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_GetAllWaitingReservations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) CreateWaitingReservation(ctx context.Context, in *CreateWaitingReservationRequest, opts ...grpc.CallOption) (*CreateWaitingReservationResponse, error) {
	out := new(CreateWaitingReservationResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_CreateWaitingReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) SeatWaitingReservation(ctx context.Context, in *SeatWaitingReservationRequest, opts ...grpc.CallOption) (*SeatWaitingReservationResponse, error) {
	out := new(SeatWaitingReservationResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_SeatWaitingReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) GetRealtimeWaitingReservations(ctx context.Context, in *GetWaitingReservationRequest, opts ...grpc.CallOption) (ReservationWaitlist_GetRealtimeWaitingReservationsClient, error) {
	stream, err := c.cc.NewStream(ctx, &ReservationWaitlist_ServiceDesc.Streams[0], ReservationWaitlist_GetRealtimeWaitingReservations_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &reservationWaitlistGetRealtimeWaitingReservationsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ReservationWaitlist_GetRealtimeWaitingReservationsClient interface {
	Recv() (*GetWaitingReservationResponse, error)
	grpc.ClientStream
}

type reservationWaitlistGetRealtimeWaitingReservationsClient struct {
	grpc.ClientStream
}

func (x *reservationWaitlistGetRealtimeWaitingReservationsClient) Recv() (*GetWaitingReservationResponse, error) {
	m := new(GetWaitingReservationResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *reservationWaitlistClient) UpdateWaitingReservationDetails(ctx context.Context, in *UpdateWaitingReservationDetailsRequest, opts ...grpc.CallOption) (*UpdateWaitingReservationDetailsResponse, error) {
	out := new(UpdateWaitingReservationDetailsResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_UpdateWaitingReservationDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) CreateWaitingReservationNote(ctx context.Context, in *CreateWaitingReservationNoteRequest, opts ...grpc.CallOption) (*CreateWaitingReservationNoteResponse, error) {
	out := new(CreateWaitingReservationNoteResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_CreateWaitingReservationNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) UpdateWaitingReservationNote(ctx context.Context, in *UpdateWaitingReservationNoteRequest, opts ...grpc.CallOption) (*UpdateWaitingReservationNoteResponse, error) {
	out := new(UpdateWaitingReservationNoteResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_UpdateWaitingReservationNote_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWaitlistClient) CreateDirectInReservation(ctx context.Context, in *CreateWaitingReservationRequest, opts ...grpc.CallOption) (*CreateReservationResponse, error) {
	out := new(CreateReservationResponse)
	err := c.cc.Invoke(ctx, ReservationWaitlist_CreateDirectInReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationWaitlistServer is the server API for ReservationWaitlist service.
// All implementations should embed UnimplementedReservationWaitlistServer
// for forward compatibility
type ReservationWaitlistServer interface {
	GetAllWaitingReservations(context.Context, *GetWaitingReservationRequest) (*GetWaitingReservationsResponse, error)
	CreateWaitingReservation(context.Context, *CreateWaitingReservationRequest) (*CreateWaitingReservationResponse, error)
	SeatWaitingReservation(context.Context, *SeatWaitingReservationRequest) (*SeatWaitingReservationResponse, error)
	GetRealtimeWaitingReservations(*GetWaitingReservationRequest, ReservationWaitlist_GetRealtimeWaitingReservationsServer) error
	UpdateWaitingReservationDetails(context.Context, *UpdateWaitingReservationDetailsRequest) (*UpdateWaitingReservationDetailsResponse, error)
	CreateWaitingReservationNote(context.Context, *CreateWaitingReservationNoteRequest) (*CreateWaitingReservationNoteResponse, error)
	UpdateWaitingReservationNote(context.Context, *UpdateWaitingReservationNoteRequest) (*UpdateWaitingReservationNoteResponse, error)
	CreateDirectInReservation(context.Context, *CreateWaitingReservationRequest) (*CreateReservationResponse, error)
}

// UnimplementedReservationWaitlistServer should be embedded to have forward compatible implementations.
type UnimplementedReservationWaitlistServer struct {
}

func (UnimplementedReservationWaitlistServer) GetAllWaitingReservations(context.Context, *GetWaitingReservationRequest) (*GetWaitingReservationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllWaitingReservations not implemented")
}
func (UnimplementedReservationWaitlistServer) CreateWaitingReservation(context.Context, *CreateWaitingReservationRequest) (*CreateWaitingReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWaitingReservation not implemented")
}
func (UnimplementedReservationWaitlistServer) SeatWaitingReservation(context.Context, *SeatWaitingReservationRequest) (*SeatWaitingReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SeatWaitingReservation not implemented")
}
func (UnimplementedReservationWaitlistServer) GetRealtimeWaitingReservations(*GetWaitingReservationRequest, ReservationWaitlist_GetRealtimeWaitingReservationsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetRealtimeWaitingReservations not implemented")
}
func (UnimplementedReservationWaitlistServer) UpdateWaitingReservationDetails(context.Context, *UpdateWaitingReservationDetailsRequest) (*UpdateWaitingReservationDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWaitingReservationDetails not implemented")
}
func (UnimplementedReservationWaitlistServer) CreateWaitingReservationNote(context.Context, *CreateWaitingReservationNoteRequest) (*CreateWaitingReservationNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWaitingReservationNote not implemented")
}
func (UnimplementedReservationWaitlistServer) UpdateWaitingReservationNote(context.Context, *UpdateWaitingReservationNoteRequest) (*UpdateWaitingReservationNoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateWaitingReservationNote not implemented")
}
func (UnimplementedReservationWaitlistServer) CreateDirectInReservation(context.Context, *CreateWaitingReservationRequest) (*CreateReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDirectInReservation not implemented")
}

// UnsafeReservationWaitlistServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationWaitlistServer will
// result in compilation errors.
type UnsafeReservationWaitlistServer interface {
	mustEmbedUnimplementedReservationWaitlistServer()
}

func RegisterReservationWaitlistServer(s grpc.ServiceRegistrar, srv ReservationWaitlistServer) {
	s.RegisterService(&ReservationWaitlist_ServiceDesc, srv)
}

func _ReservationWaitlist_GetAllWaitingReservations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWaitingReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).GetAllWaitingReservations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_GetAllWaitingReservations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).GetAllWaitingReservations(ctx, req.(*GetWaitingReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_CreateWaitingReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWaitingReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).CreateWaitingReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_CreateWaitingReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).CreateWaitingReservation(ctx, req.(*CreateWaitingReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_SeatWaitingReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeatWaitingReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).SeatWaitingReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_SeatWaitingReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).SeatWaitingReservation(ctx, req.(*SeatWaitingReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_GetRealtimeWaitingReservations_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetWaitingReservationRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReservationWaitlistServer).GetRealtimeWaitingReservations(m, &reservationWaitlistGetRealtimeWaitingReservationsServer{stream})
}

type ReservationWaitlist_GetRealtimeWaitingReservationsServer interface {
	Send(*GetWaitingReservationResponse) error
	grpc.ServerStream
}

type reservationWaitlistGetRealtimeWaitingReservationsServer struct {
	grpc.ServerStream
}

func (x *reservationWaitlistGetRealtimeWaitingReservationsServer) Send(m *GetWaitingReservationResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ReservationWaitlist_UpdateWaitingReservationDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWaitingReservationDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).UpdateWaitingReservationDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_UpdateWaitingReservationDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).UpdateWaitingReservationDetails(ctx, req.(*UpdateWaitingReservationDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_CreateWaitingReservationNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWaitingReservationNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).CreateWaitingReservationNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_CreateWaitingReservationNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).CreateWaitingReservationNote(ctx, req.(*CreateWaitingReservationNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_UpdateWaitingReservationNote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateWaitingReservationNoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).UpdateWaitingReservationNote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_UpdateWaitingReservationNote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).UpdateWaitingReservationNote(ctx, req.(*UpdateWaitingReservationNoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWaitlist_CreateDirectInReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWaitingReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWaitlistServer).CreateDirectInReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWaitlist_CreateDirectInReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWaitlistServer).CreateDirectInReservation(ctx, req.(*CreateWaitingReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationWaitlist_ServiceDesc is the grpc.ServiceDesc for ReservationWaitlist service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationWaitlist_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationWaitlist",
	HandlerType: (*ReservationWaitlistServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllWaitingReservations",
			Handler:    _ReservationWaitlist_GetAllWaitingReservations_Handler,
		},
		{
			MethodName: "CreateWaitingReservation",
			Handler:    _ReservationWaitlist_CreateWaitingReservation_Handler,
		},
		{
			MethodName: "SeatWaitingReservation",
			Handler:    _ReservationWaitlist_SeatWaitingReservation_Handler,
		},
		{
			MethodName: "UpdateWaitingReservationDetails",
			Handler:    _ReservationWaitlist_UpdateWaitingReservationDetails_Handler,
		},
		{
			MethodName: "CreateWaitingReservationNote",
			Handler:    _ReservationWaitlist_CreateWaitingReservationNote_Handler,
		},
		{
			MethodName: "UpdateWaitingReservationNote",
			Handler:    _ReservationWaitlist_UpdateWaitingReservationNote_Handler,
		},
		{
			MethodName: "CreateDirectInReservation",
			Handler:    _ReservationWaitlist_CreateDirectInReservation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetRealtimeWaitingReservations",
			Handler:       _ReservationWaitlist_GetRealtimeWaitingReservations_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationFeedbackWebhook_CreateReservationFeedbackFromWebhook_FullMethodName = "/guest_proto.reservationFeedbackWebhook/CreateReservationFeedbackFromWebhook"
)

// ReservationFeedbackWebhookClient is the client API for ReservationFeedbackWebhook service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationFeedbackWebhookClient interface {
	CreateReservationFeedbackFromWebhook(ctx context.Context, in *CreateReservationFeedbackFromWebhookRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackFromWebhookResponse, error)
}

type reservationFeedbackWebhookClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationFeedbackWebhookClient(cc grpc.ClientConnInterface) ReservationFeedbackWebhookClient {
	return &reservationFeedbackWebhookClient{cc}
}

func (c *reservationFeedbackWebhookClient) CreateReservationFeedbackFromWebhook(ctx context.Context, in *CreateReservationFeedbackFromWebhookRequest, opts ...grpc.CallOption) (*CreateReservationFeedbackFromWebhookResponse, error) {
	out := new(CreateReservationFeedbackFromWebhookResponse)
	err := c.cc.Invoke(ctx, ReservationFeedbackWebhook_CreateReservationFeedbackFromWebhook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationFeedbackWebhookServer is the server API for ReservationFeedbackWebhook service.
// All implementations should embed UnimplementedReservationFeedbackWebhookServer
// for forward compatibility
type ReservationFeedbackWebhookServer interface {
	CreateReservationFeedbackFromWebhook(context.Context, *CreateReservationFeedbackFromWebhookRequest) (*CreateReservationFeedbackFromWebhookResponse, error)
}

// UnimplementedReservationFeedbackWebhookServer should be embedded to have forward compatible implementations.
type UnimplementedReservationFeedbackWebhookServer struct {
}

func (UnimplementedReservationFeedbackWebhookServer) CreateReservationFeedbackFromWebhook(context.Context, *CreateReservationFeedbackFromWebhookRequest) (*CreateReservationFeedbackFromWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateReservationFeedbackFromWebhook not implemented")
}

// UnsafeReservationFeedbackWebhookServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationFeedbackWebhookServer will
// result in compilation errors.
type UnsafeReservationFeedbackWebhookServer interface {
	mustEmbedUnimplementedReservationFeedbackWebhookServer()
}

func RegisterReservationFeedbackWebhookServer(s grpc.ServiceRegistrar, srv ReservationFeedbackWebhookServer) {
	s.RegisterService(&ReservationFeedbackWebhook_ServiceDesc, srv)
}

func _ReservationFeedbackWebhook_CreateReservationFeedbackFromWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReservationFeedbackFromWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationFeedbackWebhookServer).CreateReservationFeedbackFromWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationFeedbackWebhook_CreateReservationFeedbackFromWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationFeedbackWebhookServer).CreateReservationFeedbackFromWebhook(ctx, req.(*CreateReservationFeedbackFromWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationFeedbackWebhook_ServiceDesc is the grpc.ServiceDesc for ReservationFeedbackWebhook service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationFeedbackWebhook_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationFeedbackWebhook",
	HandlerType: (*ReservationFeedbackWebhookServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReservationFeedbackFromWebhook",
			Handler:    _ReservationFeedbackWebhook_CreateReservationFeedbackFromWebhook_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	DayOperations_CheckIfDayClosed_FullMethodName   = "/guest_proto.dayOperations/CheckIfDayClosed"
	DayOperations_CloseDayOperations_FullMethodName = "/guest_proto.dayOperations/CloseDayOperations"
)

// DayOperationsClient is the client API for DayOperations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DayOperationsClient interface {
	CheckIfDayClosed(ctx context.Context, in *CheckIfDayClosedRequest, opts ...grpc.CallOption) (*CheckIfDayClosedResponse, error)
	CloseDayOperations(ctx context.Context, in *CloseDayOperationsRequest, opts ...grpc.CallOption) (*CloseDayOperationsResponse, error)
}

type dayOperationsClient struct {
	cc grpc.ClientConnInterface
}

func NewDayOperationsClient(cc grpc.ClientConnInterface) DayOperationsClient {
	return &dayOperationsClient{cc}
}

func (c *dayOperationsClient) CheckIfDayClosed(ctx context.Context, in *CheckIfDayClosedRequest, opts ...grpc.CallOption) (*CheckIfDayClosedResponse, error) {
	out := new(CheckIfDayClosedResponse)
	err := c.cc.Invoke(ctx, DayOperations_CheckIfDayClosed_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *dayOperationsClient) CloseDayOperations(ctx context.Context, in *CloseDayOperationsRequest, opts ...grpc.CallOption) (*CloseDayOperationsResponse, error) {
	out := new(CloseDayOperationsResponse)
	err := c.cc.Invoke(ctx, DayOperations_CloseDayOperations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DayOperationsServer is the server API for DayOperations service.
// All implementations should embed UnimplementedDayOperationsServer
// for forward compatibility
type DayOperationsServer interface {
	CheckIfDayClosed(context.Context, *CheckIfDayClosedRequest) (*CheckIfDayClosedResponse, error)
	CloseDayOperations(context.Context, *CloseDayOperationsRequest) (*CloseDayOperationsResponse, error)
}

// UnimplementedDayOperationsServer should be embedded to have forward compatible implementations.
type UnimplementedDayOperationsServer struct {
}

func (UnimplementedDayOperationsServer) CheckIfDayClosed(context.Context, *CheckIfDayClosedRequest) (*CheckIfDayClosedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckIfDayClosed not implemented")
}
func (UnimplementedDayOperationsServer) CloseDayOperations(context.Context, *CloseDayOperationsRequest) (*CloseDayOperationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseDayOperations not implemented")
}

// UnsafeDayOperationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DayOperationsServer will
// result in compilation errors.
type UnsafeDayOperationsServer interface {
	mustEmbedUnimplementedDayOperationsServer()
}

func RegisterDayOperationsServer(s grpc.ServiceRegistrar, srv DayOperationsServer) {
	s.RegisterService(&DayOperations_ServiceDesc, srv)
}

func _DayOperations_CheckIfDayClosed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckIfDayClosedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DayOperationsServer).CheckIfDayClosed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DayOperations_CheckIfDayClosed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DayOperationsServer).CheckIfDayClosed(ctx, req.(*CheckIfDayClosedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DayOperations_CloseDayOperations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseDayOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DayOperationsServer).CloseDayOperations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DayOperations_CloseDayOperations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DayOperationsServer).CloseDayOperations(ctx, req.(*CloseDayOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DayOperations_ServiceDesc is the grpc.ServiceDesc for DayOperations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DayOperations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.dayOperations",
	HandlerType: (*DayOperationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckIfDayClosed",
			Handler:    _DayOperations_CheckIfDayClosed_Handler,
		},
		{
			MethodName: "CloseDayOperations",
			Handler:    _DayOperations_CloseDayOperations_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	ReservationWidget_GetWidgetAvailableTimes_FullMethodName = "/guest_proto.reservationWidget/GetWidgetAvailableTimes"
	ReservationWidget_CreateWidgetReservation_FullMethodName = "/guest_proto.reservationWidget/CreateWidgetReservation"
)

// ReservationWidgetClient is the client API for ReservationWidget service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationWidgetClient interface {
	GetWidgetAvailableTimes(ctx context.Context, in *GetWidgetAvailableTimesRequest, opts ...grpc.CallOption) (*GetWidgetAvailableTimesResponse, error)
	CreateWidgetReservation(ctx context.Context, in *CreateWidgetReservationRequest, opts ...grpc.CallOption) (*CreateWidgetReservationResponse, error)
}

type reservationWidgetClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationWidgetClient(cc grpc.ClientConnInterface) ReservationWidgetClient {
	return &reservationWidgetClient{cc}
}

func (c *reservationWidgetClient) GetWidgetAvailableTimes(ctx context.Context, in *GetWidgetAvailableTimesRequest, opts ...grpc.CallOption) (*GetWidgetAvailableTimesResponse, error) {
	out := new(GetWidgetAvailableTimesResponse)
	err := c.cc.Invoke(ctx, ReservationWidget_GetWidgetAvailableTimes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationWidgetClient) CreateWidgetReservation(ctx context.Context, in *CreateWidgetReservationRequest, opts ...grpc.CallOption) (*CreateWidgetReservationResponse, error) {
	out := new(CreateWidgetReservationResponse)
	err := c.cc.Invoke(ctx, ReservationWidget_CreateWidgetReservation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationWidgetServer is the server API for ReservationWidget service.
// All implementations should embed UnimplementedReservationWidgetServer
// for forward compatibility
type ReservationWidgetServer interface {
	GetWidgetAvailableTimes(context.Context, *GetWidgetAvailableTimesRequest) (*GetWidgetAvailableTimesResponse, error)
	CreateWidgetReservation(context.Context, *CreateWidgetReservationRequest) (*CreateWidgetReservationResponse, error)
}

// UnimplementedReservationWidgetServer should be embedded to have forward compatible implementations.
type UnimplementedReservationWidgetServer struct {
}

func (UnimplementedReservationWidgetServer) GetWidgetAvailableTimes(context.Context, *GetWidgetAvailableTimesRequest) (*GetWidgetAvailableTimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWidgetAvailableTimes not implemented")
}
func (UnimplementedReservationWidgetServer) CreateWidgetReservation(context.Context, *CreateWidgetReservationRequest) (*CreateWidgetReservationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWidgetReservation not implemented")
}

// UnsafeReservationWidgetServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationWidgetServer will
// result in compilation errors.
type UnsafeReservationWidgetServer interface {
	mustEmbedUnimplementedReservationWidgetServer()
}

func RegisterReservationWidgetServer(s grpc.ServiceRegistrar, srv ReservationWidgetServer) {
	s.RegisterService(&ReservationWidget_ServiceDesc, srv)
}

func _ReservationWidget_GetWidgetAvailableTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWidgetAvailableTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWidgetServer).GetWidgetAvailableTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWidget_GetWidgetAvailableTimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWidgetServer).GetWidgetAvailableTimes(ctx, req.(*GetWidgetAvailableTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationWidget_CreateWidgetReservation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateWidgetReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationWidgetServer).CreateWidgetReservation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationWidget_CreateWidgetReservation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationWidgetServer).CreateWidgetReservation(ctx, req.(*CreateWidgetReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationWidget_ServiceDesc is the grpc.ServiceDesc for ReservationWidget service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationWidget_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.reservationWidget",
	HandlerType: (*ReservationWidgetServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetWidgetAvailableTimes",
			Handler:    _ReservationWidget_GetWidgetAvailableTimes_Handler,
		},
		{
			MethodName: "CreateWidgetReservation",
			Handler:    _ReservationWidget_CreateWidgetReservation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}

const (
	Payment_SendPaymentRequest_FullMethodName        = "/guest_proto.payment/SendPaymentRequest"
	Payment_GetPaymentByID_FullMethodName            = "/guest_proto.payment/GetPaymentByID"
	Payment_GetAllReservationPayments_FullMethodName = "/guest_proto.payment/GetAllReservationPayments"
	Payment_UpdatePaymentFromWebhook_FullMethodName  = "/guest_proto.payment/UpdatePaymentFromWebhook"
	Payment_CancelPayment_FullMethodName             = "/guest_proto.payment/CancelPayment"
)

// PaymentClient is the client API for Payment service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PaymentClient interface {
	SendPaymentRequest(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*PaymentResponse, error)
	GetPaymentByID(ctx context.Context, in *GetPaymentByIDRequest, opts ...grpc.CallOption) (*GetPaymentByIDResponse, error)
	GetAllReservationPayments(ctx context.Context, in *GetAllReservationPaymentsRequest, opts ...grpc.CallOption) (*GetAllReservationPaymentsResponse, error)
	UpdatePaymentFromWebhook(ctx context.Context, in *UpdatePaymentFromWebhookRequest, opts ...grpc.CallOption) (*UpdatePaymentFromWebhookResponse, error)
	CancelPayment(ctx context.Context, in *CancelPaymentRequest, opts ...grpc.CallOption) (*CancelPaymentResponse, error)
}

type paymentClient struct {
	cc grpc.ClientConnInterface
}

func NewPaymentClient(cc grpc.ClientConnInterface) PaymentClient {
	return &paymentClient{cc}
}

func (c *paymentClient) SendPaymentRequest(ctx context.Context, in *PaymentRequest, opts ...grpc.CallOption) (*PaymentResponse, error) {
	out := new(PaymentResponse)
	err := c.cc.Invoke(ctx, Payment_SendPaymentRequest_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) GetPaymentByID(ctx context.Context, in *GetPaymentByIDRequest, opts ...grpc.CallOption) (*GetPaymentByIDResponse, error) {
	out := new(GetPaymentByIDResponse)
	err := c.cc.Invoke(ctx, Payment_GetPaymentByID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) GetAllReservationPayments(ctx context.Context, in *GetAllReservationPaymentsRequest, opts ...grpc.CallOption) (*GetAllReservationPaymentsResponse, error) {
	out := new(GetAllReservationPaymentsResponse)
	err := c.cc.Invoke(ctx, Payment_GetAllReservationPayments_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) UpdatePaymentFromWebhook(ctx context.Context, in *UpdatePaymentFromWebhookRequest, opts ...grpc.CallOption) (*UpdatePaymentFromWebhookResponse, error) {
	out := new(UpdatePaymentFromWebhookResponse)
	err := c.cc.Invoke(ctx, Payment_UpdatePaymentFromWebhook_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *paymentClient) CancelPayment(ctx context.Context, in *CancelPaymentRequest, opts ...grpc.CallOption) (*CancelPaymentResponse, error) {
	out := new(CancelPaymentResponse)
	err := c.cc.Invoke(ctx, Payment_CancelPayment_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PaymentServer is the server API for Payment service.
// All implementations should embed UnimplementedPaymentServer
// for forward compatibility
type PaymentServer interface {
	SendPaymentRequest(context.Context, *PaymentRequest) (*PaymentResponse, error)
	GetPaymentByID(context.Context, *GetPaymentByIDRequest) (*GetPaymentByIDResponse, error)
	GetAllReservationPayments(context.Context, *GetAllReservationPaymentsRequest) (*GetAllReservationPaymentsResponse, error)
	UpdatePaymentFromWebhook(context.Context, *UpdatePaymentFromWebhookRequest) (*UpdatePaymentFromWebhookResponse, error)
	CancelPayment(context.Context, *CancelPaymentRequest) (*CancelPaymentResponse, error)
}

// UnimplementedPaymentServer should be embedded to have forward compatible implementations.
type UnimplementedPaymentServer struct {
}

func (UnimplementedPaymentServer) SendPaymentRequest(context.Context, *PaymentRequest) (*PaymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendPaymentRequest not implemented")
}
func (UnimplementedPaymentServer) GetPaymentByID(context.Context, *GetPaymentByIDRequest) (*GetPaymentByIDResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPaymentByID not implemented")
}
func (UnimplementedPaymentServer) GetAllReservationPayments(context.Context, *GetAllReservationPaymentsRequest) (*GetAllReservationPaymentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllReservationPayments not implemented")
}
func (UnimplementedPaymentServer) UpdatePaymentFromWebhook(context.Context, *UpdatePaymentFromWebhookRequest) (*UpdatePaymentFromWebhookResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePaymentFromWebhook not implemented")
}
func (UnimplementedPaymentServer) CancelPayment(context.Context, *CancelPaymentRequest) (*CancelPaymentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelPayment not implemented")
}

// UnsafePaymentServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PaymentServer will
// result in compilation errors.
type UnsafePaymentServer interface {
	mustEmbedUnimplementedPaymentServer()
}

func RegisterPaymentServer(s grpc.ServiceRegistrar, srv PaymentServer) {
	s.RegisterService(&Payment_ServiceDesc, srv)
}

func _Payment_SendPaymentRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).SendPaymentRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Payment_SendPaymentRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).SendPaymentRequest(ctx, req.(*PaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_GetPaymentByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPaymentByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).GetPaymentByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Payment_GetPaymentByID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).GetPaymentByID(ctx, req.(*GetPaymentByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_GetAllReservationPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllReservationPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).GetAllReservationPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Payment_GetAllReservationPayments_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).GetAllReservationPayments(ctx, req.(*GetAllReservationPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_UpdatePaymentFromWebhook_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePaymentFromWebhookRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).UpdatePaymentFromWebhook(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Payment_UpdatePaymentFromWebhook_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).UpdatePaymentFromWebhook(ctx, req.(*UpdatePaymentFromWebhookRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Payment_CancelPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PaymentServer).CancelPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Payment_CancelPayment_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PaymentServer).CancelPayment(ctx, req.(*CancelPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Payment_ServiceDesc is the grpc.ServiceDesc for Payment service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Payment_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "guest_proto.payment",
	HandlerType: (*PaymentServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendPaymentRequest",
			Handler:    _Payment_SendPaymentRequest_Handler,
		},
		{
			MethodName: "GetPaymentByID",
			Handler:    _Payment_GetPaymentByID_Handler,
		},
		{
			MethodName: "GetAllReservationPayments",
			Handler:    _Payment_GetAllReservationPayments_Handler,
		},
		{
			MethodName: "UpdatePaymentFromWebhook",
			Handler:    _Payment_UpdatePaymentFromWebhook_Handler,
		},
		{
			MethodName: "CancelPayment",
			Handler:    _Payment_CancelPayment_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/guest_service.proto",
}
